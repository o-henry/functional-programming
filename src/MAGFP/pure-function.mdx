## Oh to Be Pure Again

`순수함수`는 동일한 input 에는 항상 동일한 output을 리턴해야 하고, 사이드 이펙트가 없는 함수다.
`slice` 와 `splice`는 같은 동작을 하나 pure/impure로 나뉜다.
함수형 프로그래밍에서는 `splice` 같이 data를 변경시키는 다루기 힘든 함수를 싫어한다.

```js
// impure
let minimum = 21;
const checkAge = (age) => age >= minimum;

// pure
const chekcAge = (age) => {
  const minimum = 21;
  // const immutableState = Object.freeze({ minimum: 21 })
  return age >= minimum;
};
```

impure 부분에서는 chekcAge 함수가 mutable 한 변수인 minium에 의존하여 값을 결정한다.
it depends on system state which is disappointing because it increases the cognitive load by introducing an external environment.
위 예제에서는 많지 않아 보일 수 있지만, mutable한 변수에 의존도는 시스템 복잡성에 가장 큰 영향을 미치는 요인중 하나.
외부 입력에 따라 다른 결과를 반환 한다.

## 사이드 이펙트

`사이드 이펙트`는 예상하는 기대값 이외의 발생하는 모든 효과를 말합니다.

- changing the file system
- inserting a record into a database
- making an http call
- mutations
- printing to the screen / logging
- obtaining user input
- querying the DOM
- accessing system state

함수 외부에서의 상호작용은 모두 사이드 이펙트 입니다.
위와 같은 사이드 이펙트들이 없는 프로그래밍의 실용성을 의심하게 되는게 사실입니다. 하지만,
함수형 프로그래밍의 철학은 사이드 이펙트들이 잘못된 동작의 주요 원인이라고 가정합니다.

위 의 사항들을 사용하지 않는것이 아닌, 통제된 방식으로 컨트롤 가능하도록 실행하기를 원합니다.

## The Case for Purity

### Cacheable (캐싱)

### Portable / Self-documenting (이식성, 주입(의존성), 자체 문서화)

함수 의존성이 명시적이므로 보고 이해하기가 쉽다.

```js
// impure
const signUp = (attrs) => {
  const user = saveUser(attrs);
  welcomeUser(user);
};

//pure
const signUp = (Db, Email, attrs) => () => {
  const user = saveUser(Db, attrs);
  welcomeUser(Email, user);
};
```

### Testable (테스팅)

### Reasonable (referential transparency)

### Parallel Code

When was the last time you copied a method into a new app?
One of my favorite quotes comes from Erlang creator,
Joe Armstrong: "The problem with object-oriented languages is they’ve got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana... and the entire jungle".
